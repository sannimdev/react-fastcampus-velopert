# `리덕스`

-   `리덕스`는 리액트 생태계에서 가장 많이 사용하는 상태관리 라이브러리이다.
-   상태 관리 로직을 다른 파일로 분리하여 더욱 효율적으로 분리할 수 있고 글로벌 상태를 관리하기가 수월하다.
-   🤷‍♂️ 그런데 Context API + useReducer 조합만으로도 사용이 가능한데 굳이 `리덕스`를 사용해야 할까?
    -   `리덕스`를 사용하는 것과 개발방식이 매우 유사하다.
    -   Reducer, Action 사용이 가능하다는 점도 유사하다.
    -   그러나 Context API는 지금의 형태(v16~17)와는 사용 방식이 완전히 달랐고 불편했다.
    -   그래서 리액트 프로젝트에서 전역 상태를 관리할 때는 Redux를 사용하는 것이 당연시됐다.
-   참고로 `리덕스`는 리액트를 위해 만들어졌지만 일반 자바스크립트나 앵귤러와 같은 조합으로도 사용이 가능하다.
-   그러나 많이 사용된다고 해서 `리덕스`의 도입이 무조건 필요한 것을 의미하는 것은 아니다.

## Context API를 사용하는 것과 다른 점이 무엇인가?

1. `미들웨어`라는 기능
    - 특정 조건에 따라 액션이 무시할 수 있음
    - 액션을 콘솔에 출력하거나, 서버 쪽에 로깅할 수 있음.
    - 액션이 디스패치됐을 때 이를 수정하여 리듀서에 전달되게 할 수 있다.
    - 특정 액션이 발생할 때 이에 기반하여 다른 액션이 발생되도록 할 수 있다.
    - 특정 액션이 발생했을 때 특정 자바스크립트 함수를 실행할 수 있다.
    - 비동기 작업을 더욱 체계적으로 관리할 수 있음.
2. 유용한 함수와 Hook를 지원받을 수 있다.
    - Context API를 사용할 때는 새로운 Context를 만들 때마다 `Context.Provider` 설정, 전역 커스텀 훅 등의 반복적인 작업이 필요했다.
    - `connect`: 전역적인 상태 `dispatch` 함수 등을 Props로 받아서 처리할 수 있다.
    - `useSelector`, `useDispatch`, `useStore`: 리덕스에서 관리하는 상태를 쉽게 조회하거나 dispatch할 수 있다. 이 함수 덕분에 따로 만들어서 사용하지 않고 만들어진 함수를 이용하여 사용하므로 수월하다.
3. 기본적인 최적화가 이미 수행돼 있다.
    - 필요한 상태가 바뀔 때에만 리렌더링되는 기능이 내재돼 있다.
    - 그러므로 부가적으로 최적화 작업을 직접 수행할 수고를 일부 덜어준다.
4. 하나의 커다란 상태

-   Context API에서는 글로벌 상태를 관리할 때 기능별로 Context를 사용하는 것이 일반적이었다.
-   그러나 리덕스에서는 모든 글로벌 상태를 하나의 커다란 객체에 넣어 사용하는 것이 필수적이다.
    -   그러므로 매번 Context를 만들어야 하는 수고를 덜 수 있다.

5. DevTools
    - 유용한 개발자 도구
6. 이미 사용중인 프로젝트가 많다.

## 리덕스는 언제 써야 할까? 체크리스트

-   ✔ 프로젝트의 규모가 큰가요?
-   ✔ 비동기 작업 처리를 자주 해야 하나요?
-   ✔ 리덕스가 편하게 느껴지나요?
    -   편하지 않다면 `MobX`라는 라이브러리가 있다. 그러나 작동 방식이 리덕스와 다름에 유의한다.
    -   리덕스를 고집하지 않고 다른 라이브러리를 사용하는 것 또한 방법이다.

리덕스가 편하게 느껴지는지 아닌지를 알기 위해서는 일단 배워봐야 알 것이다.

# 리덕스에서 사용되는 키워드 숙지하기

## 액션(Action)

-   상태에 어떠한 변화가 필요할 때 액션(Action)을 발생시킨다.
    -   하나의 객체로 표현된다.
        ```js
        {
            type: 'TOGGLE_VALUE',
            data: {
                id: 0,
                text: '리덕스 배우기',
            }
        }
        ```
        ```js
        {
            type: 'CHANGE_INPUT',
            text: '안녕하세요',
        }
        ```
    -   상태를 바꿀 때 어떻게 업데이트할 것인지를 정의하는 것이라고 할 수 있다.

## 액션 생성함수 (Action Creator)

-   액션을 만들어주는 함수. 파라미터를 받아와서 액션 객체를 만들어주는 함수이다.

    ```js
    export function addTodo(data) {
        return {
            type: 'ADD_TODO',
            data,
        };
    }

    /* 😁 화살표 함수로도 만들 수 있다. */
    export const changeInput = (text) => ({
        type: 'CHANGE_INPUT',
        text,
    });
    ```

## 리듀서 (Reducer)

-   이전에 리듀서 훅을 사용했을 때의 개념과 완전히 같다.
-   리듀서는 변화를 일으키는 함수이다.

    ```js
    /*
        😁 action의 type이 무엇인지별로 다른 업데이트 작업을 한다. 
        단, 객체의 경우에는 불변성을 유지해주는 작업을 반드시 수행해줘야 한다. 
        ❌ 기존의 객체나 배열을 건드려서는 안 된다!
        ❌ useReducer를 사용할 때는 default에 오류를 발생시킨 것과 달리 Redux에서는 
            그대로 상태를 반환해야 한다.
                - 왜냐하면 여러 개의 리듀서를 합쳐 루트 리듀서를 만들 수 있는기 때문이다(?)
    */

    function counter(state, action) {
        switch (action.type) {
            case 'INCREASE':
                return state + 1;
            case 'DECREASE':
                return state - 1;
            default:
                return state;
        }
    }
    ```

## 스토어 (Store)

-   1개의 Application당 1개의 스토어를 가진다.
-   몇 가지 내장함수가 들어 있다.
    1.  디스패치 `dispatch`: 액션을 발생시키는 것 or 액션을 Store에 전달하는 것
        ```js
        dispatch({ type: 'INCREASE' });
        ```
    2.  구독 `subscribe`
        -   이 함수를 호출할 때 파라미터로 `특정 함수`를 넣어주면 액션이 `dispatch`될 때마다 해당 함수가 실행된다.
        -   redux를 사용할 때 이 함수를 직접 사용할 일은 거의 없다.
            하지만, react-redux가 제공하는 `connect` 함수 혹은 `useSelector` 훅을 사용하여 Store의 상태가 업데이트되면 컴포넌트를 리렌더링하도록 작업을 대신 처리해준다.

# 리덕스를 사용할 때 주의사항

## 1. 하나의 애플리케이션에는 하나의 스토어만 존재한다.

-   여러 개의 스토어를 만들 수 있지만, 이는 권장하지 않는다.
-   스토어가 여러 개가 될 경우에는 개발자 도구를 제대로 활용할 수 없다.

## 2. 상태는 읽기전용이다.

-   즉, 불변성을 지켜줘야 한다.
-   리액트를 개발하면서 불변성을 지켜주는 것이 익숙하므로 이를 리덕스를 사용하면서도 불변성을 지키면 된다.
-   불변성을 지켜야만 컴포넌트가 제대로 리렌더링된다.

## 3. 변화를 일으키는 함수 리듀서는 순수한 함수여야 한다.

-   리듀서 함수는 이전 상태와 액션 객체를 파라미터로 받는다.
-   이전 상태는 절대로 변경하지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다.
-   **똑같은 파라미터**로 호출된 리듀서 함수는 **언제나 똑같은 결괏값**을 반환해야 한다.
-   동일한 입력 ▶ 동일한 출력
    -   `new Date()`, `Math.random()`, `axios.get()`과 같은 함수를 이용하면 동일한 출력을 보장받을 수 없다.
    -   이외에도 바깥에 있는 변수에 의존하는 것 또한 안 된다. 상수라면 변함없는 값이겠지만, 변수의 경우에는 값이 바뀌므로 결괏값이 달라질 수도 있다.

# 리덕스 프로젝트 만들어 보기

## 리덕스 모듈 만들기

-   액션 타입
-   액션 생성 함수
-   리듀서

-   Redux github repository의 [Todos Example](https://github.com/reduxjs/redux/tree/master/examples/todos/src)의 폴더 구조를 보면 `actions`와 `reducers`를 구분지어 사용하고 있는 것을 확인할 수 있다.
-   그러나 본 프로젝트에서는 하나의 파일에 몰아서 작성해 보도록 할 것이다. (`Ducks 패턴`)
    -   이는 파일 안에 Action Type, Action 생성함수, Reducer 모두 몰아서 작성하는 것이다.
    -   단, Reducer의 경우에는 `export default`로 액션 생성함수는 `export`로 내보내 준다.
    -   처음에 배우는 과정에서 사용하면 굉장히 쉽다.
