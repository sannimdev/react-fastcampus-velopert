-   본 디렉터리는 리덕스 튜토리얼을 복습학기 위해 작성하는 2회독 프로젝트입니다.
-   아직 리덕스에 대한 개념에 관해서는 알고 있지만
    유기적으로 얽히고설킨 개념(디스패치, 액션, 액션 생성함수의 상호작용 등)을 좀 더 완벽하게 소화하고자
    리듀서 미들웨어 프로젝트로 들어가기 전에 다시 한 번 더 복습하는 튜토리얼입니다.

# 리덕스

-   가장 사용률이 높은 상태 관리 라이브러리
-   `Context API + useReducer` 이 두 가지의 조합은 리덕스를 사용하는 것과 매우 흡사하다.
-   Context API는 과거에 사용하는 방식이 현재 사용하는 방식과 달랐음.
-   리액트와 무조건 함께 사용될 필요는 없고 바닐라 자바스크립트나 다른 프레임워크와도 조합하여 사용할 수 있다.
-   그러나 많이 사용된다고해서 리덕스가 프로젝트에 무조건 포함시켜야 하는 것은 아니다!
-   단순히 글로벌 상태만을 위한 것이거나 글로벌 상태를 관리할 필요성을 느끼지 못한다면 Context API를 사용해도 무방하다.

## 리덕스 미들웨어의 기능

-   이는 ContextAPI를 사용하는 방식과는 조금 차이가 있다.
-   특정 조건에 따라 액션이 무시되게 할 수 있음.
-   액션을 콘솔에 출력하거나, 서버쪽에 로깅할 수 있음.
-   액션이 디스패치 되었을 때 이를 수정하여 리듀서에게 전달되도록 한다.
-   특정 액션이 발생했을 떄 이에 기반하여 다른 액션이 발생되도록 할 수 있다.
-   특정 액션이 발생했을 떄 특정 자바스크립트 함수를 실행시킬 수 있다.

1. 비동기 작업을 더욱 체계적으로 관리할 수 있다.
2. 유용한 함수와 Hooks를 이용할 수 있다.
    - 기존 Context API를 편하게 사용하려면 커스텀 훅을 만드는 작업 등을 해줘야 하지만
      리덕스 미들웨어에서는 기본적으로 제공하는 `connect`, `useSelector`, `useDispatch`, `useStore` 함수를 사용하면 된다.
3. 기본적인 최적화가 이미 되어 있다.
4. 하나의 커다란 상태를 가진다.
    - Context는 기능별로 하나의 Context를 만들어 관리했지만, 리덕스는 하나의 상태를 가진다.
5. DevTools를 이용하여 개발을 디버깅하기가 매우 편리하다.
6. 이미 (리덕스를) 사용하고 있는 프로젝트가 많다.

## 리덕스를 써야 하는 시점

1. 프로젝트의 규모가 큰 경우
2. 비동기 작업 처리가 많은 경우 (+Redux Middleware)
3. 리덕스가 편하게 느껴지는 경우 (아닐 경우 Context API 혹은 MobX 등 사용)

## 리덕스에서 사용되는 용어 📕

1. 액션(ACtion)

-   상태에 변화가 필요할 때 액션을 발생시킨다.
-   액션은 객체이다.
    ```js
    const 액션1 = {
        type: 'TOGGLE_VALUE',
    };
    const 액션2 = {
        type: 'ADD_TODO',
        data: {
            id: 0,
            texT: '리덕스 배우기',
        },
    };
    ```

2. 액션 생성함수 (Action Creator)

```js
export function addTodo(data) {
    return {
        type: 'ADD_TODO',
        data,
    };
}

// 화살표 함수로도 만들 수 있다.
export const changeInput = (text) => ({
    type: 'CHANGE_INPUT',
    text,
});
```

-   액션 생성함수를 사용하는 것이 필수적인 것은 아니다.
-   그러나 액션 생성함수를 만들어 두면 편하게 액션을 만들 수 있다.
-   액션 생성함수가 없으면 직접 액션을 작성해 주면 된다.

3. 리듀서 (Reducer)

-   Context API에서 만났던 그 친구와 개념이 동일하다.

```js
function counter(state, action) {
    switch (action.type) {
        case 'INCREASE':
            return state + 1;
        case 'DECREASE':
            return state - 1;
        default:
            return state;
    }
}
```

🤷‍♂️📕 주의사항

-   만약에 객체를 반환한다면 객체는 새로운 객체를 만들어 반환해야 한다.
    -   객체는 불변성을 유지한다는 법칙이 리덕스에서 매우 중요하다.
-   리덕스 리듀서에서는 default의 경우에는 기존의 상태 그대로를 반환해야 한다.
    -   리덕스르 사용할 떄 여러 개의 리듀서를 만들고 루트 리듀서를 만들게 되는데 이때 유용하기 때문이다.

4. 스토어 (Store)

-   기본적으로 하나의 앱에 하나의 스토어만 들어있다고 생각하면 된다.
-   몇 가지 내장함수가 들어 있다.
    -   `dispatch`: 액션을 발생시키는 것 (액션을 store에 전달하는 것)
        ```js
        dispatch({ type: 'INCREASE' });
        ```
    -   `구독 (subscribe)`: 파라미터로 특정 함수를 넣어주면 액션이 dispatch될 때마다 호출된다.
        store의 상태가 업데이트될 때마다 구독하고 있는 함수가 계속해서 호출된다는 뜻이다.
        다만, 직접 구독 함수를 사용한다기보다는 `connect` 함수, `useSelect` 훅을 사용하여 Store상태가 업데이트되면 리렌더링되는 작업을 대신 처리해 준다.

## 리덕스를 사용할 떄 3가지 규칙

1. 하나의 애플리케이션에는 하나의 스토어가 있다.

    - 스토어를 한 개를 초과하여 만들면 안 된다. 여러 개를 만들 수는 있으나 권장하지 않는다.
    - 특정 업데이트가 빈번하게 일어나거나 애플리케이션이 특정 부분을 완전히 분리할 때만 이용하나 일반적으로 사용하는 방법은 아니다.
    - 개발자 도구의 제대로 된 지원을 받을 수 없다.

2. 상태는 읽기전용이다. (불변성을 지켜야 한다.)

    - 객체의 경우나 배열의 경우에는 불변성을 반드시 지켜야 한다.
        - 불변성을 지키는 내장함수를 이용하면 좋다.
        - 리덕스에서 불변성을 지키는 것이 좋은 성능을 지키는 것이며 컴포넌트의 변화를 제대로 감지할 수 있다.

3. 변화를 일으키는 리듀서 함수는 순수 함수여야 한다.
    - 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받는다.
    - 이전의 상태는 변경하지 않고 변화를 일으킨 새로운 상태 객체를 만들어 반환해야 한다.
    - 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결괏값을 반환해야 한다.
      즉, 동일한 입력이 일어나도 결괏값은 동일해야 한다는 의미이다.
        - 따라서 new Date(), Math.random(), axios.get()과 같이 호출할 떄마다 다른 값을 가져오는 함수를 이용해서는 안 된다.
        - 바깥의 변수를 의존해서도 안 된다.

## 리덕스 패턴

### Ducks 패턴

-   이번 프로젝트에서는 하나의 파일에 모아 작성할 것이다. 그것을 바로 `Ducks 패턴`이라 한다.
    -   파일 안에 Action Type, Action 생성함수, Reducer 한 번에 작성한다.
    -   Reducer는 `export default`로 선언하고 액션 생성함수는 `export`로 선언한다.
